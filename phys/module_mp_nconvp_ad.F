
MODULE a_module_mp_nconvp

CONTAINS

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.5 (r3785) - 22 Mar 2011 18:35
!
!  Differentiation of lscond in reverse (adjoint) mode:
!   gradient     of useful results: th qv rainnc rainncv
!   with respect to varying inputs: th p qv rainnc rainncv rho
!                pii dz8w
!   RW status of diff variables: th:in-out p:out qv:in-out rainnc:in-out
!                rainncv:in-out rho:out pii:out dz8w:out
! domain dims
! memory dims
! tile   dims
SUBROUTINE A_LSCOND(th, a_th, p, a_p, qv, a_qv, rho, a_rho, pii, a_pii, r_v, &
&  xlv, cp, ep2, svp1, svp2, svp3, svpt0, dz8w, a_dz8w, rainnc, a_rainnc, &
&  rainncv, a_rainncv, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, &
&  kms, kme, its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
!----------------------------------------------------------------
!  based on MM5 code (JD November 2006)
!----------------------------------------------------------------
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte
  REAL, INTENT(IN) :: r_v, xlv, cp
  REAL, INTENT(IN) :: ep2, svp1, svp2, svp3, svpt0
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: th, qv
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_th, a_qv
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: rho, pii, p&
&  , dz8w
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_rho, a_pii, a_p, a_dz8w
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: rainnc, rainncv
  REAL, DIMENSION(ims:ime, jms:jme) :: a_rainnc, a_rainncv
! local variables
  REAL :: ttemp, es1, qs1, dqv, cond, r1
  REAL :: ttempb, es1b, qs1b, dqvb, condb, r1b
  INTEGER :: i, j, k
  INTEGER :: branch
  REAL :: temp1
  REAL :: temp0
  REAL :: temp0b
  REAL :: temp2b1
  REAL :: temp2b0
  REAL :: tempb
  REAL :: temp0b0
  REAL :: temp2b
  REAL :: temp1b
  REAL :: temp
!----------------------------------------------------------------
  DO j=jts,jte
    DO k=kts,kte
      DO i=its,ite
        CALL PUSHREAL8(ttemp)
        ttemp = pii(i, k, j)*th(i, k, j)
        CALL PUSHREAL8(es1)
        es1 = 1000.*svp1*EXP(svp2*(ttemp-svpt0)/(ttemp-svp3))
        qs1 = ep2*es1/(p(i, k, j)-es1)
        CALL PUSHREAL8(dqv)
        dqv = qv(i, k, j) - qs1
        IF (dqv .GT. 0.0) THEN
          CALL PUSHREAL8(r1)
          r1 = 1. + xlv*xlv/(r_v*cp)*qs1/(ttemp*ttemp)
          cond = dqv/r1
          CALL PUSHREAL8(ttemp)
          ttemp = ttemp + xlv/cp*cond
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
  END DO
  a_p = 0.0
  a_rho = 0.0
  a_pii = 0.0
  a_dz8w = 0.0
  DO j=jte,jts,-1
    DO k=kte,kts,-1
      DO i=ite,its,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qs1b = 0.0
          dqvb = 0.0
          ttempb = 0.0
        ELSE
          temp2b1 = a_th(i, k, j)/pii(i, k, j)
          ttempb = temp2b1
          temp2b0 = dz8w(i, k, j)*a_rainncv(i, j)
          cond = dqv/r1
          temp2b = dz8w(i, k, j)*a_rainnc(i, j)
          a_rho(i, k, j) = a_rho(i, k, j) + cond*temp2b0 + cond*temp2b
          condb = rho(i, k, j)*temp2b0 - a_qv(i, k, j) + xlv*ttempb/cp + &
&            rho(i, k, j)*temp2b
          a_dz8w(i, k, j) = a_dz8w(i, k, j) + rho(i, k, j)*cond*a_rainncv(i&
&            , j) + rho(i, k, j)*cond*a_rainnc(i, j)
          a_rainncv(i, j) = 0.0
          a_pii(i, k, j) = a_pii(i, k, j) - ttemp*temp2b1/pii(i, k, j)
          a_th(i, k, j) = 0.0
          qs1 = ep2*es1/(p(i, k, j)-es1)
          CALL POPREAL8(ttemp)
          dqvb = condb/r1
          r1b = -(dqv*condb/r1**2)
          CALL POPREAL8(r1)
          temp1 = r_v*cp*ttemp**2
          temp1b = xlv**2*r1b/temp1
          qs1b = temp1b
          ttempb = ttempb - r_v*cp*qs1*2*ttemp*temp1b/temp1
        END IF
        CALL POPREAL8(dqv)
        a_qv(i, k, j) = a_qv(i, k, j) + dqvb
        qs1b = qs1b - dqvb
        temp0 = p(i, k, j) - es1
        temp0b = ep2*qs1b/temp0
        temp0b0 = -(es1*temp0b/temp0)
        es1b = temp0b - temp0b0
        a_p(i, k, j) = a_p(i, k, j) + temp0b0
        CALL POPREAL8(es1)
        temp = (ttemp-svpt0)/(ttemp-svp3)
        tempb = svp2*EXP(svp2*temp)*svp1*1000.*es1b/(ttemp-svp3)
        ttempb = ttempb + (1.0-temp)*tempb
        CALL POPREAL8(ttemp)
        a_pii(i, k, j) = a_pii(i, k, j) + th(i, k, j)*ttempb
        a_th(i, k, j) = a_th(i, k, j) + pii(i, k, j)*ttempb
      END DO
    END DO
  END DO
END SUBROUTINE A_LSCOND

END MODULE a_module_mp_nconvp

