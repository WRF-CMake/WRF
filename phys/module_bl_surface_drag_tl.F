
 MODULE g_module_bl_surface_drag

 CONTAINS

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.5 (r3678) - 11 Feb 2011 13:58
!
!  Differentiation of surface_drag in forward (tangent) mode:
!   variations   of useful results: rublten rvblten
!   with respect to varying inputs: v_phy rublten z rvblten u_phy
!   RW status of diff variables: v_phy:in rublten:in-out z:in rvblten:in-out
!                u_phy:in
SUBROUTINE G_SURFACE_DRAG(rublten, g_rublten, rvblten, g_rvblten, u_phy, &
   g_u_phy, v_phy, g_v_phy, xland, z, g_z, ht, ids, ide, jds, jde, kds, kde&
   , ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
   jme, kms, kme, its, ite, jts, jte, kts, kte
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rublten, rvblten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: g_rublten, g_rvblten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u_phy, v_phy, z
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_u_phy, g_v_phy, g_z
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: xland, ht
! Local
  REAL :: v0, tao_xz, tao_yz, cd, zh, zwt
  REAL :: v0d, tao_xzd, tao_yzd, cdd, zhd, zwtd
  INTEGER :: i, j, i_start, i_end, i_endu, j_start, j_end, j_endv, k
  REAL :: arg1
  REAL :: arg1d
  INTRINSIC MAX
  INTRINSIC ABS
  REAL :: abs2
  REAL :: abs1
  INTRINSIC MIN
  INTRINSIC SQRT
! End declarations.
!-----------------------------------------------------------------------
  i_start = its
  IF (ite .GT. ide - 1) THEN
    i_end = ide - 1
  ELSE
    i_end = ite
  END IF
  i_endu = ite
  j_start = jts
  IF (jte .GT. jde - 1) THEN
    j_end = jde - 1
  ELSE
    j_end = jte
  END IF
  j_endv = jte
  DO j=j_start,j_end
    DO i=i_start,i_endu
      arg1d = 2*u_phy(i, kts, j)*g_u_phy(i, kts, j) + 2*v_phy(i, kts, j)*&
         g_v_phy(i, kts, j)
      arg1 = u_phy(i, kts, j)**2 + v_phy(i, kts, j)**2
      IF (arg1 .EQ. 0.0) THEN
        v0d = 0.0
      ELSE
        v0d = arg1d/(2.0*SQRT(arg1))
      END IF
      v0 = SQRT(arg1)
      IF (xland(i, j) - xland(i-1, j) .GE. 0.) THEN
        abs1 = xland(i, j) - xland(i-1, j)
      ELSE
        abs1 = -(xland(i, j)-xland(i-1, j))
      END IF
      IF (abs1 .LT. 1.0e-10) THEN
        IF (xland(i, j) .LT. 1.5) THEN
! land
          cd = 0.01
          cdd = 0.0
        ELSE
! water
          cd = 0.001
          IF (cd .LT. 1.e-4*v0) THEN
            cdd = 1.e-4*v0d
            cd = 1.e-4*v0
          ELSE
            cd = cd
            cdd = 0.0
          END IF
          IF (cd .GT. 0.003) THEN
            cd = 0.003
            cdd = 0.0
          ELSE
            cd = cd
          END IF
        END IF
      ELSE
! coast
        cd = 0.003
        cdd = 0.0
      END IF
      tao_xzd = (cdd*v0+cd*v0d)*u_phy(i, kts, j) + cd*v0*g_u_phy(i, kts, j)
      tao_xz = cd*v0*u_phy(i, kts, j)
      DO k=kts,kte
        zhd = g_z(i, k, j)
        zh = z(i, k, j) - ht(i, j)
        IF (zh .LT. 1000.) THEN
          zwtd = (-(2.*zhd))/1000.
          zwt = 2.*(1000.-zh)/1000.
          g_rublten(i, k, j) = g_rublten(i, k, j) - 0.5*(zwtd*tao_xz+zwt*&
             tao_xzd)/1000.
          rublten(i, k, j) = rublten(i, k, j) - zwt*0.5*tao_xz/1000.
        END IF
      END DO
    END DO
  END DO
!
  DO j=j_start,j_endv
    DO i=i_start,i_end
      arg1d = 2*u_phy(i, kts, j)*g_u_phy(i, kts, j) + 2*v_phy(i, kts, j)*&
         g_v_phy(i, kts, j)
      arg1 = u_phy(i, kts, j)**2 + v_phy(i, kts, j)**2
      IF (arg1 .EQ. 0.0) THEN
        v0d = 0.0
      ELSE
        v0d = arg1d/(2.0*SQRT(arg1))
      END IF
      v0 = SQRT(arg1)
      IF (xland(i, j) - xland(i, j-1) .GE. 0.) THEN
        abs2 = xland(i, j) - xland(i, j-1)
      ELSE
        abs2 = -(xland(i, j)-xland(i, j-1))
      END IF
      IF (abs2 .LT. 1.0e-10) THEN
        IF (xland(i, j) .LT. 1.5) THEN
! land
          cd = 0.01
          cdd = 0.0
        ELSE
! water
          cd = 0.001
          IF (cd .LT. 1.e-4*v0) THEN
            cdd = 1.e-4*v0d
            cd = 1.e-4*v0
          ELSE
            cd = cd
            cdd = 0.0
          END IF
          IF (cd .GT. 0.003) THEN
            cd = 0.003
            cdd = 0.0
          ELSE
            cd = cd
          END IF
        END IF
      ELSE
! coast
        cd = 0.003
        cdd = 0.0
      END IF
      tao_yzd = (cdd*v0+cd*v0d)*v_phy(i, kts, j) + cd*v0*g_v_phy(i, kts, j)
      tao_yz = cd*v0*v_phy(i, kts, j)
      DO k=kts,kte
        zhd = g_z(i, k, j)
        zh = z(i, k, j) - ht(i, j)
        IF (zh .LT. 1000.) THEN
          zwtd = (-(2.*zhd))/1000.
          zwt = 2.*(1000.-zh)/1000.
          g_rvblten(i, k, j) = g_rvblten(i, k, j) - 0.5*(zwtd*tao_yz+zwt*&
             tao_yzd)/1000.
          rvblten(i, k, j) = rvblten(i, k, j) - zwt*0.5*tao_yz/1000.
        END IF
      END DO
    END DO
  END DO
END SUBROUTINE G_SURFACE_DRAG

END MODULE g_module_bl_surface_drag
